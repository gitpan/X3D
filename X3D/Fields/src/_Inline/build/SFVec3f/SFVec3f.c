/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of SFVec3f.xs. Do not edit this file, edit SFVec3f.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "SFVec3f.xs"
#ifndef bool
#include <iostream.h>
#endif
extern "C" {
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "INLINE.h"
}
#ifdef bool
#undef bool
#include <iostream.h>
#endif


class SFVec3f {
	public:
		double x;
		double y;
		double z;

	public:
		SFVec3f (const double x=0, const double y=0, const double z=0) { setValue(x,y,z); }

		inline const SFVec3f* copy () { return new SFVec3f(x,y,z); }
		
		inline void setValue (const double x, const double y, const double z) {
			this->x = x;
			this->y = y;
			this->z = z;
		}
		
		inline void getValue () {
			Inline_Stack_Vars;
			Inline_Stack_Reset;
				Inline_Stack_Push(sv_2mortal(newSVnv(x)));
				Inline_Stack_Push(sv_2mortal(newSVnv(y)));
				Inline_Stack_Push(sv_2mortal(newSVnv(z)));
			Inline_Stack_Done;
		}
		
		inline void setX (const double x) { this->x = x; }
		inline void setY (const double y) { this->y = y; }
		inline void setZ (const double z) { this->z = z; }

		inline const double getX () { return x; }
		inline const double getY () { return y; }
		inline const double getZ () { return z; }

		inline const SFVec3f* negate (SV* s=0) {
			return new SFVec3f(
				-x,
				-y,
				-z
			);
		}
		
		inline const SFVec3f* add (SFVec3f* v, SV* s=0) {
			return new SFVec3f(
				x + v->x,
				y + v->y,
				z + v->z
			);
		}
		
		inline const SFVec3f* subtract (SFVec3f* v, SV* s=0) {
			return new SFVec3f(
				x - v->x,
				y - v->y,
				z - v->z
			);
		}

		inline const SFVec3f* multiply (const double v, SV* s=0) {
			return new SFVec3f(
				x * v,
				y * v,
				z * v
			);
		}

		inline const SFVec3f* divide (const double v, SV* s=0) {
			return new SFVec3f(
				x / v,
				y / v,
				z / v
			);
		}

		inline const double dot (SFVec3f* v, SV* s=0) {
			return 
				x * v->x +
				y * v->y +
				z * v->z
			;
		}

		inline const SFVec3f* cross (SFVec3f* v, SV* s=0) {
			return new SFVec3f(
				y * v->z - z * v->y,
				z * v->x - x * v->z,
				x * v->y - y * v->x
			);
		}

		inline const double length (SV* s=0) {
			return sqrt(
				x*x +
				y*y +
				z*z
			);
		}
	
		inline const SFVec3f* normalize () {
			return divide(length());
		}

};


#line 131 "SFVec3f.c"
XS(XS_main__SFVec3f_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_new)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::new(CLASS, ...)");
    {
#line 128 "SFVec3f.xs"
	double	x;
	double	y;
	double	z;
#line 143 "SFVec3f.c"
	char *	CLASS = (char *)SvPV_nolen(ST(0));
	SFVec3f *	RETVAL;
#line 132 "SFVec3f.xs"
switch(items-1) {
case 1:
	x = (double)SvNV(ST(1));
	RETVAL = new SFVec3f(x);
	break; /* case 1 */
case 2:
	x = (double)SvNV(ST(1));
	y = (double)SvNV(ST(2));
	RETVAL = new SFVec3f(x,y);
	break; /* case 2 */
case 3:
	x = (double)SvNV(ST(1));
	y = (double)SvNV(ST(2));
	z = (double)SvNV(ST(3));
	RETVAL = new SFVec3f(x,y,z);
	break; /* case 3 */
default:
	RETVAL = new SFVec3f();
} /* switch(items) */ 
#line 166 "SFVec3f.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec3f", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_copy); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_copy)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::copy(THIS)");
    {
	SFVec3f *	THIS;
	SFVec3f *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 157 "SFVec3f.xs"
	RETVAL = const_cast<SFVec3f *>(THIS->copy());
#line 194 "SFVec3f.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec3f", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_setValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_setValue)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::setValue(THIS, x, y, z)");
    SP -= items;
    {
	double	x = (double)SvNV(ST(1));
	double	y = (double)SvNV(ST(2));
	double	z = (double)SvNV(ST(3));
#line 167 "SFVec3f.xs"
	I32 *	__temp_markstack_ptr;
#line 216 "SFVec3f.c"
	SFVec3f *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 169 "SFVec3f.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setValue(x,y,z);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 236 "SFVec3f.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFVec3f_getValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_getValue)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::getValue(THIS)");
    SP -= items;
    {
#line 182 "SFVec3f.xs"
	I32 *	__temp_markstack_ptr;
#line 252 "SFVec3f.c"
	SFVec3f *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 184 "SFVec3f.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->getValue();
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 272 "SFVec3f.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFVec3f_setX); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_setX)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::setX(THIS, x)");
    SP -= items;
    {
	double	x = (double)SvNV(ST(1));
#line 198 "SFVec3f.xs"
	I32 *	__temp_markstack_ptr;
#line 289 "SFVec3f.c"
	SFVec3f *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 200 "SFVec3f.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setX(x);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 309 "SFVec3f.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFVec3f_setY); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_setY)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::setY(THIS, y)");
    SP -= items;
    {
	double	y = (double)SvNV(ST(1));
#line 214 "SFVec3f.xs"
	I32 *	__temp_markstack_ptr;
#line 326 "SFVec3f.c"
	SFVec3f *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 216 "SFVec3f.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setY(y);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 346 "SFVec3f.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFVec3f_setZ); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_setZ)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::setZ(THIS, z)");
    SP -= items;
    {
	double	z = (double)SvNV(ST(1));
#line 230 "SFVec3f.xs"
	I32 *	__temp_markstack_ptr;
#line 363 "SFVec3f.c"
	SFVec3f *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 232 "SFVec3f.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setZ(z);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 383 "SFVec3f.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFVec3f_getX); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_getX)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::getX(THIS)");
    {
	SFVec3f *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 245 "SFVec3f.xs"
	RETVAL = THIS->getX();
#line 409 "SFVec3f.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_getY); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_getY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::getY(THIS)");
    {
	SFVec3f *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 252 "SFVec3f.xs"
	RETVAL = THIS->getY();
#line 435 "SFVec3f.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_getZ); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_getZ)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::getZ(THIS)");
    {
	SFVec3f *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 259 "SFVec3f.xs"
	RETVAL = THIS->getZ();
#line 461 "SFVec3f.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_negate); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_negate)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::negate(THIS, ...)");
    {
#line 266 "SFVec3f.xs"
	SV *	s;
#line 476 "SFVec3f.c"
	SFVec3f *	THIS;
	SFVec3f *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 268 "SFVec3f.xs"
switch(items-1) {
case 1:
	s = ST(1);
	RETVAL = const_cast<SFVec3f *>(THIS->negate(s));
	break; /* case 1 */
default:
	RETVAL = const_cast<SFVec3f *>(THIS->negate());
} /* switch(items) */ 
#line 496 "SFVec3f.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec3f", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_add)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::add(THIS, v, ...)");
    {
	SFVec3f *	v;
#line 283 "SFVec3f.xs"
	SV *	s;
#line 515 "SFVec3f.c"
	SFVec3f *	THIS;
	SFVec3f *	RETVAL;

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)) {
        v = (SFVec3f *)SvIV((SV*)SvRV( ST(1) ));
    }
    else {
        warn ( "SFVec3f::() -- v is not a blessed reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 285 "SFVec3f.xs"
switch(items-1) {
case 2:
	s = ST(2);
	RETVAL = const_cast<SFVec3f *>(THIS->add(v,s));
	break; /* case 2 */
default:
	RETVAL = const_cast<SFVec3f *>(THIS->add(v));
} /* switch(items) */ 
#line 543 "SFVec3f.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec3f", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_subtract); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_subtract)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::subtract(THIS, v, ...)");
    {
	SFVec3f *	v;
#line 300 "SFVec3f.xs"
	SV *	s;
#line 562 "SFVec3f.c"
	SFVec3f *	THIS;
	SFVec3f *	RETVAL;

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)) {
        v = (SFVec3f *)SvIV((SV*)SvRV( ST(1) ));
    }
    else {
        warn ( "SFVec3f::() -- v is not a blessed reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 302 "SFVec3f.xs"
switch(items-1) {
case 2:
	s = ST(2);
	RETVAL = const_cast<SFVec3f *>(THIS->subtract(v,s));
	break; /* case 2 */
default:
	RETVAL = const_cast<SFVec3f *>(THIS->subtract(v));
} /* switch(items) */ 
#line 590 "SFVec3f.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec3f", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_multiply); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_multiply)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::multiply(THIS, v, ...)");
    {
	double	v = (double)SvNV(ST(1));
#line 317 "SFVec3f.xs"
	SV *	s;
#line 609 "SFVec3f.c"
	SFVec3f *	THIS;
	SFVec3f *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 319 "SFVec3f.xs"
switch(items-1) {
case 2:
	s = ST(2);
	RETVAL = const_cast<SFVec3f *>(THIS->multiply(v,s));
	break; /* case 2 */
default:
	RETVAL = const_cast<SFVec3f *>(THIS->multiply(v));
} /* switch(items) */ 
#line 629 "SFVec3f.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec3f", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_divide); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_divide)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::divide(THIS, v, ...)");
    {
	double	v = (double)SvNV(ST(1));
#line 334 "SFVec3f.xs"
	SV *	s;
#line 648 "SFVec3f.c"
	SFVec3f *	THIS;
	SFVec3f *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 336 "SFVec3f.xs"
switch(items-1) {
case 2:
	s = ST(2);
	RETVAL = const_cast<SFVec3f *>(THIS->divide(v,s));
	break; /* case 2 */
default:
	RETVAL = const_cast<SFVec3f *>(THIS->divide(v));
} /* switch(items) */ 
#line 668 "SFVec3f.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec3f", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_dot); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_dot)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::dot(THIS, v, ...)");
    {
	SFVec3f *	v;
#line 351 "SFVec3f.xs"
	SV *	s;
#line 687 "SFVec3f.c"
	SFVec3f *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)) {
        v = (SFVec3f *)SvIV((SV*)SvRV( ST(1) ));
    }
    else {
        warn ( "SFVec3f::() -- v is not a blessed reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 353 "SFVec3f.xs"
switch(items-1) {
case 2:
	s = ST(2);
	RETVAL = THIS->dot(v,s);
	break; /* case 2 */
default:
	RETVAL = THIS->dot(v);
} /* switch(items) */ 
#line 716 "SFVec3f.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_cross); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_cross)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::cross(THIS, v, ...)");
    {
	SFVec3f *	v;
#line 368 "SFVec3f.xs"
	SV *	s;
#line 732 "SFVec3f.c"
	SFVec3f *	THIS;
	SFVec3f *	RETVAL;

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)) {
        v = (SFVec3f *)SvIV((SV*)SvRV( ST(1) ));
    }
    else {
        warn ( "SFVec3f::() -- v is not a blessed reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 370 "SFVec3f.xs"
switch(items-1) {
case 2:
	s = ST(2);
	RETVAL = const_cast<SFVec3f *>(THIS->cross(v,s));
	break; /* case 2 */
default:
	RETVAL = const_cast<SFVec3f *>(THIS->cross(v));
} /* switch(items) */ 
#line 760 "SFVec3f.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec3f", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_length); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_length)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::length(THIS, ...)");
    {
#line 384 "SFVec3f.xs"
	SV *	s;
#line 778 "SFVec3f.c"
	SFVec3f *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 386 "SFVec3f.xs"
switch(items-1) {
case 1:
	s = ST(1);
	RETVAL = THIS->length(s);
	break; /* case 1 */
default:
	RETVAL = THIS->length();
} /* switch(items) */ 
#line 799 "SFVec3f.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_normalize); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_normalize)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::normalize(THIS)");
    {
	SFVec3f *	THIS;
	SFVec3f *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 400 "SFVec3f.xs"
	RETVAL = const_cast<SFVec3f *>(THIS->normalize());
#line 824 "SFVec3f.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec3f", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec3f_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec3f_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec3f::DESTROY(THIS)");
    {
	SFVec3f *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec3f *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec3f::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };

	delete THIS;
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_SFVec3f); /* prototype to pass -Wmissing-prototypes */
XS(boot_SFVec3f)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("main::SFVec3f::new", XS_main__SFVec3f_new, file);
        newXS("main::SFVec3f::copy", XS_main__SFVec3f_copy, file);
        newXS("main::SFVec3f::setValue", XS_main__SFVec3f_setValue, file);
        newXS("main::SFVec3f::getValue", XS_main__SFVec3f_getValue, file);
        newXS("main::SFVec3f::setX", XS_main__SFVec3f_setX, file);
        newXS("main::SFVec3f::setY", XS_main__SFVec3f_setY, file);
        newXS("main::SFVec3f::setZ", XS_main__SFVec3f_setZ, file);
        newXS("main::SFVec3f::getX", XS_main__SFVec3f_getX, file);
        newXS("main::SFVec3f::getY", XS_main__SFVec3f_getY, file);
        newXS("main::SFVec3f::getZ", XS_main__SFVec3f_getZ, file);
        newXS("main::SFVec3f::negate", XS_main__SFVec3f_negate, file);
        newXS("main::SFVec3f::add", XS_main__SFVec3f_add, file);
        newXS("main::SFVec3f::subtract", XS_main__SFVec3f_subtract, file);
        newXS("main::SFVec3f::multiply", XS_main__SFVec3f_multiply, file);
        newXS("main::SFVec3f::divide", XS_main__SFVec3f_divide, file);
        newXS("main::SFVec3f::dot", XS_main__SFVec3f_dot, file);
        newXS("main::SFVec3f::cross", XS_main__SFVec3f_cross, file);
        newXS("main::SFVec3f::length", XS_main__SFVec3f_length, file);
        newXS("main::SFVec3f::normalize", XS_main__SFVec3f_normalize, file);
        newXS("main::SFVec3f::DESTROY", XS_main__SFVec3f_DESTROY, file);
    XSRETURN_YES;
}

