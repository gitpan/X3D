/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of SFFloat.xs. Do not edit this file, edit SFFloat.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "SFFloat.xs"
#ifndef bool
#include <iostream.h>
#endif
extern "C" {
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "INLINE.h"
}
#ifdef bool
#undef bool
#include <iostream.h>
#endif


class SFFloat {
	private:
		double value;

	public:
		SFFloat (const double v=0) { setValue(v); }

		inline const SFFloat* copy () { return new SFFloat(value); }

		inline void setValue (const double v) { value = v; }
		inline const double getValue () { return value; }

		//inline void madd      (const double v) { value += v; }
		//inline void msubtract (const double v) { value -= v; }
		//inline void mmultiply (const double v) { value *= v; }
		//inline void mdivide   (const double v) { value /= v; }
	
		//inline const SFFloat* add      (const double v) { return new SFFloat(value + v); }
		//inline const SFFloat* subtract (const double v) { return new SFFloat(value - v); }
		//inline const SFFloat* multiply (const double v) { return new SFFloat(value * v); }
		//inline const SFFloat* divide   (const double v) { return new SFFloat(value / v); }
};


#line 50 "SFFloat.c"
XS(XS_main__SFFloat_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFFloat_new)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: main::SFFloat::new(CLASS, ...)");
    {
#line 47 "SFFloat.xs"
	double	v;
#line 60 "SFFloat.c"
	char *	CLASS = (char *)SvPV_nolen(ST(0));
	SFFloat *	RETVAL;
#line 49 "SFFloat.xs"
switch(items-1) {
case 1:
	v = (double)SvNV(ST(1));
	RETVAL = new SFFloat(v);
	break; /* case 1 */
default:
	RETVAL = new SFFloat();
} /* switch(items) */ 
#line 72 "SFFloat.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFFloat", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFFloat_copy); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFFloat_copy)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFFloat::copy(THIS)");
    {
	SFFloat *	THIS;
	SFFloat *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFFloat *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFFloat::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 63 "SFFloat.xs"
	RETVAL = const_cast<SFFloat *>(THIS->copy());
#line 100 "SFFloat.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFFloat", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFFloat_setValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFFloat_setValue)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFFloat::setValue(THIS, v)");
    SP -= items;
    {
	double	v = (double)SvNV(ST(1));
#line 71 "SFFloat.xs"
	I32 *	__temp_markstack_ptr;
#line 120 "SFFloat.c"
	SFFloat *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFFloat *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFFloat::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 73 "SFFloat.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setValue(v);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 140 "SFFloat.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFFloat_getValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFFloat_getValue)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFFloat::getValue(THIS)");
    {
	SFFloat *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFFloat *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFFloat::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 86 "SFFloat.xs"
	RETVAL = THIS->getValue();
#line 166 "SFFloat.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFFloat_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFFloat_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFFloat::DESTROY(THIS)");
    {
	SFFloat *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFFloat *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFFloat::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };

	delete THIS;
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_SFFloat); /* prototype to pass -Wmissing-prototypes */
XS(boot_SFFloat)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("main::SFFloat::new", XS_main__SFFloat_new, file);
        newXS("main::SFFloat::copy", XS_main__SFFloat_copy, file);
        newXS("main::SFFloat::setValue", XS_main__SFFloat_setValue, file);
        newXS("main::SFFloat::getValue", XS_main__SFFloat_getValue, file);
        newXS("main::SFFloat::DESTROY", XS_main__SFFloat_DESTROY, file);
    XSRETURN_YES;
}

