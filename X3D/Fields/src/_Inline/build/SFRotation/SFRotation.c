/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of SFRotation.xs. Do not edit this file, edit SFRotation.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "SFRotation.xs"
#ifndef bool
#include <iostream.h>
#endif
extern "C" {
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "INLINE.h"
}
#ifdef bool
#undef bool
#include <iostream.h>
#endif


#include "Quaternion.cpp"

class SFRotation {
	public:
		SFVec3f* axis;
		double angle;
		Quaternion* q;

	private:
		SFRotation (Quaternion* q) {
			axis  = new SFVec3f();
 			angle = 0;
			this->q = q;
			this->q->getAxisAngle(axis, angle);
		}

	public:
		SFRotation (   ) {
			Inline_Stack_Vars;
			switch (Inline_Stack_Items-1) {
				case 0:
					axis  = new SFVec3f(0,0,1);
					angle = 0;
					q     = new Quaternion();
					break;
				case 1: break;
				case 2:
					if (sv_isobject(Inline_Stack_Item(1)) && (SvTYPE(SvRV(Inline_Stack_Item(1))) == SVt_PVMG)) {
						if (sv_isobject(Inline_Stack_Item(2)) && (SvTYPE(SvRV(Inline_Stack_Item(2))) == SVt_PVMG)) {
							axis  = new SFVec3f();
							angle = 0;
							q     = new Quaternion(
								(SFVec3f*)SvIV((SV*)SvRV(Inline_Stack_Item(1))),
								(SFVec3f*)SvIV((SV*)SvRV(Inline_Stack_Item(2)))
							);
							q->getAxisAngle(axis, angle);
						}
				   	else {
							axis  = ((SFVec3f*)SvIV((SV*)SvRV(Inline_Stack_Item(1))))->copy();
							angle = SvNV(Inline_Stack_Item(2));
							q     = new Quaternion(axis, angle);
				   	}
					}
				   else {
				   	warn ( "SFRotation::new(vec1, angle | vec2) -- vec1 is not a blessed reference" );
				   	XSRETURN_UNDEF;
				   }
					break;
				case 3: break;
				case 4:
					axis  = new SFVec3f(
						SvNV(Inline_Stack_Item(1)),
						SvNV(Inline_Stack_Item(2)),
						SvNV(Inline_Stack_Item(3))
					);
					angle = SvNV(Inline_Stack_Item(4));
					q     = new Quaternion(axis, angle);
					break;
				default:
					break;
			}
		}
		
		~SFRotation () { delete axis; delete q; }

		//inline const SFRotation* copy () { return new SFRotation(axis,angle); }
		
		inline void setX     (const double x) { this->axis->x = x; q->setRotation(axis, angle); }
		inline void setY     (const double y) { this->axis->y = y; q->setRotation(axis, angle); }
		inline void setZ     (const double z) { this->axis->z = z; q->setRotation(axis, angle); }
		inline void setAngle (const double a) { this->angle   = a; q->setRotation(axis, angle); }

		inline const double getX     () { return axis->x; }
		inline const double getY     () { return axis->y; }
		inline const double getZ     () { return axis->z; }
		inline const double getAngle () { return   angle; }
		
		inline const SFVec3f* getAxis() { return axis->copy(); }
		
		inline const SFRotation* inverse() { return new SFRotation (q->inverse()); }
		
		inline const SFRotation* multiply(const SFRotation* rotation) {
			return new SFRotation (q->multiply(rotation->q)); 
		}
		
		inline const SFVec3f* multVec(const SFVec3f* vec) {
			return q->multVec(vec); 
		}
		
		inline void setAxis(const SFVec3f* v) {
			axis->setValue(v->x, v->y, v->z);
			q->setRotation(axis, angle);
		}
		
		inline const SFRotation* slerp(const SFRotation* destRotation, const double t) {
			return new SFRotation (q->slerp(destRotation->q, t)); 
		}

};

#line 126 "SFRotation.c"
XS(XS_main__SFRotation_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_new)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: main::SFRotation::new(CLASS, ...)");
    {
#line 123 "SFRotation.xs"
	I32 *	__temp_markstack_ptr;
#line 136 "SFRotation.c"
	char *	CLASS = (char *)SvPV_nolen(ST(0));
	SFRotation *	RETVAL;
#line 125 "SFRotation.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	RETVAL = new SFRotation();
	PL_markstack_ptr = __temp_markstack_ptr;
#line 143 "SFRotation.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFRotation", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFRotation_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFRotation::DESTROY(THIS)");
    {
	SFRotation *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };

	delete THIS;
    }
    XSRETURN_EMPTY;
}

XS(XS_main__SFRotation_setX); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_setX)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFRotation::setX(THIS, x)");
    SP -= items;
    {
	double	x = (double)SvNV(ST(1));
#line 138 "SFRotation.xs"
	I32 *	__temp_markstack_ptr;
#line 185 "SFRotation.c"
	SFRotation *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 140 "SFRotation.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setX(x);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 205 "SFRotation.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFRotation_setY); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_setY)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFRotation::setY(THIS, y)");
    SP -= items;
    {
	double	y = (double)SvNV(ST(1));
#line 154 "SFRotation.xs"
	I32 *	__temp_markstack_ptr;
#line 222 "SFRotation.c"
	SFRotation *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 156 "SFRotation.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setY(y);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 242 "SFRotation.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFRotation_setZ); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_setZ)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFRotation::setZ(THIS, z)");
    SP -= items;
    {
	double	z = (double)SvNV(ST(1));
#line 170 "SFRotation.xs"
	I32 *	__temp_markstack_ptr;
#line 259 "SFRotation.c"
	SFRotation *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 172 "SFRotation.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setZ(z);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 279 "SFRotation.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFRotation_setAngle); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_setAngle)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFRotation::setAngle(THIS, a)");
    SP -= items;
    {
	double	a = (double)SvNV(ST(1));
#line 186 "SFRotation.xs"
	I32 *	__temp_markstack_ptr;
#line 296 "SFRotation.c"
	SFRotation *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 188 "SFRotation.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setAngle(a);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 316 "SFRotation.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFRotation_getX); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_getX)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFRotation::getX(THIS)");
    {
	SFRotation *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 201 "SFRotation.xs"
	RETVAL = THIS->getX();
#line 342 "SFRotation.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFRotation_getY); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_getY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFRotation::getY(THIS)");
    {
	SFRotation *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 208 "SFRotation.xs"
	RETVAL = THIS->getY();
#line 368 "SFRotation.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFRotation_getZ); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_getZ)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFRotation::getZ(THIS)");
    {
	SFRotation *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 215 "SFRotation.xs"
	RETVAL = THIS->getZ();
#line 394 "SFRotation.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFRotation_getAngle); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_getAngle)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFRotation::getAngle(THIS)");
    {
	SFRotation *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 222 "SFRotation.xs"
	RETVAL = THIS->getAngle();
#line 420 "SFRotation.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFRotation_getAxis); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_getAxis)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFRotation::getAxis(THIS)");
    {
	SFRotation *	THIS;
	SFVec3f *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 229 "SFRotation.xs"
	RETVAL = const_cast<SFVec3f *>(THIS->getAxis());
#line 445 "SFRotation.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec3f", (void*)RETVAL );

    }
    XSRETURN(1);
}

XS(XS_main__SFRotation_inverse); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_inverse)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFRotation::inverse(THIS)");
    {
	SFRotation *	THIS;
	SFRotation *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 236 "SFRotation.xs"
	RETVAL = const_cast<SFRotation *>(THIS->inverse());
#line 472 "SFRotation.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFRotation", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFRotation_multiply); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_multiply)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFRotation::multiply(THIS, rotation)");
    {
	SFRotation *	rotation;
	SFRotation *	THIS;
	SFRotation *	RETVAL;

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)) {
        rotation = (SFRotation *)SvIV((SV*)SvRV( ST(1) ));
    }
    else {
        warn ( "SFRotation::() -- rotation is not a blessed reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 244 "SFRotation.xs"
	RETVAL = const_cast<SFRotation *>(THIS->multiply(rotation));
#line 509 "SFRotation.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFRotation", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFRotation_multVec); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_multVec)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFRotation::multVec(THIS, vec)");
    {
	SFVec3f *	vec;
	SFRotation *	THIS;
	SFVec3f *	RETVAL;

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)) {
        vec = (SFVec3f *)SvIV((SV*)SvRV( ST(1) ));
    }
    else {
        warn ( "SFVec3f::() -- vec is not a blessed reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 252 "SFRotation.xs"
	RETVAL = const_cast<SFVec3f *>(THIS->multVec(vec));
#line 546 "SFRotation.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec3f", (void*)RETVAL );

    }
    XSRETURN(1);
}

XS(XS_main__SFRotation_setAxis); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_setAxis)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFRotation::setAxis(THIS, v)");
    SP -= items;
    {
	SFVec3f *	v;
#line 260 "SFRotation.xs"
	I32 *	__temp_markstack_ptr;
#line 565 "SFRotation.c"
	SFRotation *	THIS;

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)) {
        v = (SFVec3f *)SvIV((SV*)SvRV( ST(1) ));
    }
    else {
        warn ( "SFVec3f::() -- v is not a blessed reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 262 "SFRotation.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setAxis(v);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 593 "SFRotation.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFRotation_slerp); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFRotation_slerp)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: main::SFRotation::slerp(THIS, destRotation, t)");
    {
	SFRotation *	destRotation;
	double	t = (double)SvNV(ST(2));
	SFRotation *	THIS;
	SFRotation *	RETVAL;

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)) {
        destRotation = (SFRotation *)SvIV((SV*)SvRV( ST(1) ));
    }
    else {
        warn ( "SFRotation::() -- destRotation is not a blessed reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFRotation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFRotation::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 277 "SFRotation.xs"
	RETVAL = const_cast<SFRotation *>(THIS->slerp(destRotation,t));
#line 628 "SFRotation.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFRotation", (void*)RETVAL );


    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_SFRotation); /* prototype to pass -Wmissing-prototypes */
XS(boot_SFRotation)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("main::SFRotation::new", XS_main__SFRotation_new, file);
        newXS("main::SFRotation::DESTROY", XS_main__SFRotation_DESTROY, file);
        newXS("main::SFRotation::setX", XS_main__SFRotation_setX, file);
        newXS("main::SFRotation::setY", XS_main__SFRotation_setY, file);
        newXS("main::SFRotation::setZ", XS_main__SFRotation_setZ, file);
        newXS("main::SFRotation::setAngle", XS_main__SFRotation_setAngle, file);
        newXS("main::SFRotation::getX", XS_main__SFRotation_getX, file);
        newXS("main::SFRotation::getY", XS_main__SFRotation_getY, file);
        newXS("main::SFRotation::getZ", XS_main__SFRotation_getZ, file);
        newXS("main::SFRotation::getAngle", XS_main__SFRotation_getAngle, file);
        newXS("main::SFRotation::getAxis", XS_main__SFRotation_getAxis, file);
        newXS("main::SFRotation::inverse", XS_main__SFRotation_inverse, file);
        newXS("main::SFRotation::multiply", XS_main__SFRotation_multiply, file);
        newXS("main::SFRotation::multVec", XS_main__SFRotation_multVec, file);
        newXS("main::SFRotation::setAxis", XS_main__SFRotation_setAxis, file);
        newXS("main::SFRotation::slerp", XS_main__SFRotation_slerp, file);
    XSRETURN_YES;
}

