/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of SFVec2d.xs. Do not edit this file, edit SFVec2d.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "SFVec2d.xs"
#ifndef bool
#include <iostream.h>
#endif
extern "C" {
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "INLINE.h"
}
#ifdef bool
#undef bool
#include <iostream.h>
#endif


class SFVec2d {
	public:
		double x;
		double y;

	public:
		SFVec2d (const double x=0, const double y=0) { setValue(x,y); }

		inline const SFVec2d* copy () { return new SFVec2d(x,y); }
		
		inline void setValue (const double x, const double y) {
			this->x = x;
			this->y = y;
		}
		
		inline void getValue () {
			Inline_Stack_Vars;
			Inline_Stack_Reset;
				Inline_Stack_Push(sv_2mortal(newSVnv(x)));
				Inline_Stack_Push(sv_2mortal(newSVnv(y)));
			Inline_Stack_Done;
		}
		
		inline void setX (const double x) { this->x = x; }
		inline void setY (const double y) { this->y = y; }

		inline const double getX () { return x; }
		inline const double getY () { return y; }

		inline const SFVec2d* negate (SV* s=0) {
			return new SFVec2d(
				-x,
				-y
			);
		}
		
		inline const SFVec2d* add (SFVec2d* v, SV* s=0) {
			return new SFVec2d(
				x + v->x,
				y + v->y
			);
		}
		
		inline const SFVec2d* subtract (SFVec2d* v, SV* s=0) {
			return new SFVec2d(
				x - v->x,
				y - v->y
			);
		}

		inline const SFVec2d* multiply (const double v, SV* s=0) {
			return new SFVec2d(
				x * v,
				y * v
			);
		}

		inline const SFVec2d* divide (const double v, SV* s=0) {
			return new SFVec2d(
				x / v,
				y / v
			);
		}

		inline const double dot (SFVec2d* v, SV* s=0) {
			return 
				x * v->x +
				y * v->y
			;
		}

		inline const double length (SV* s=0) {
			return sqrt(
				x*x +
				y*y
			);
		}
	
		inline const SFVec2d* normalize () {
			return divide(length());
		}

};


#line 111 "SFVec2d.c"
XS(XS_main__SFVec2d_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_new)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::new(CLASS, ...)");
    {
#line 108 "SFVec2d.xs"
	double	x;
	double	y;
#line 122 "SFVec2d.c"
	char *	CLASS = (char *)SvPV_nolen(ST(0));
	SFVec2d *	RETVAL;
#line 111 "SFVec2d.xs"
switch(items-1) {
case 1:
	x = (double)SvNV(ST(1));
	RETVAL = new SFVec2d(x);
	break; /* case 1 */
case 2:
	x = (double)SvNV(ST(1));
	y = (double)SvNV(ST(2));
	RETVAL = new SFVec2d(x,y);
	break; /* case 2 */
default:
	RETVAL = new SFVec2d();
} /* switch(items) */ 
#line 139 "SFVec2d.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec2d", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_copy); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_copy)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::copy(THIS)");
    {
	SFVec2d *	THIS;
	SFVec2d *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 130 "SFVec2d.xs"
	RETVAL = const_cast<SFVec2d *>(THIS->copy());
#line 167 "SFVec2d.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec2d", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_setValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_setValue)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::setValue(THIS, x, y)");
    SP -= items;
    {
	double	x = (double)SvNV(ST(1));
	double	y = (double)SvNV(ST(2));
#line 139 "SFVec2d.xs"
	I32 *	__temp_markstack_ptr;
#line 188 "SFVec2d.c"
	SFVec2d *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 141 "SFVec2d.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setValue(x,y);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 208 "SFVec2d.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFVec2d_getValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_getValue)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::getValue(THIS)");
    SP -= items;
    {
#line 154 "SFVec2d.xs"
	I32 *	__temp_markstack_ptr;
#line 224 "SFVec2d.c"
	SFVec2d *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 156 "SFVec2d.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->getValue();
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 244 "SFVec2d.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFVec2d_setX); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_setX)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::setX(THIS, x)");
    SP -= items;
    {
	double	x = (double)SvNV(ST(1));
#line 170 "SFVec2d.xs"
	I32 *	__temp_markstack_ptr;
#line 261 "SFVec2d.c"
	SFVec2d *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 172 "SFVec2d.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setX(x);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 281 "SFVec2d.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFVec2d_setY); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_setY)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::setY(THIS, y)");
    SP -= items;
    {
	double	y = (double)SvNV(ST(1));
#line 186 "SFVec2d.xs"
	I32 *	__temp_markstack_ptr;
#line 298 "SFVec2d.c"
	SFVec2d *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 188 "SFVec2d.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->setY(y);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 318 "SFVec2d.c"
	PUTBACK;
	return;
    }
}

XS(XS_main__SFVec2d_getX); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_getX)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::getX(THIS)");
    {
	SFVec2d *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 201 "SFVec2d.xs"
	RETVAL = THIS->getX();
#line 344 "SFVec2d.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_getY); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_getY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::getY(THIS)");
    {
	SFVec2d *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 208 "SFVec2d.xs"
	RETVAL = THIS->getY();
#line 370 "SFVec2d.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_negate); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_negate)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::negate(THIS, ...)");
    {
#line 215 "SFVec2d.xs"
	SV *	s;
#line 385 "SFVec2d.c"
	SFVec2d *	THIS;
	SFVec2d *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 217 "SFVec2d.xs"
switch(items-1) {
case 1:
	s = ST(1);
	RETVAL = const_cast<SFVec2d *>(THIS->negate(s));
	break; /* case 1 */
default:
	RETVAL = const_cast<SFVec2d *>(THIS->negate());
} /* switch(items) */ 
#line 405 "SFVec2d.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec2d", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_add)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::add(THIS, v, ...)");
    {
	SFVec2d *	v;
#line 232 "SFVec2d.xs"
	SV *	s;
#line 424 "SFVec2d.c"
	SFVec2d *	THIS;
	SFVec2d *	RETVAL;

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)) {
        v = (SFVec2d *)SvIV((SV*)SvRV( ST(1) ));
    }
    else {
        warn ( "SFVec2d::() -- v is not a blessed reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 234 "SFVec2d.xs"
switch(items-1) {
case 2:
	s = ST(2);
	RETVAL = const_cast<SFVec2d *>(THIS->add(v,s));
	break; /* case 2 */
default:
	RETVAL = const_cast<SFVec2d *>(THIS->add(v));
} /* switch(items) */ 
#line 452 "SFVec2d.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec2d", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_subtract); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_subtract)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::subtract(THIS, v, ...)");
    {
	SFVec2d *	v;
#line 249 "SFVec2d.xs"
	SV *	s;
#line 471 "SFVec2d.c"
	SFVec2d *	THIS;
	SFVec2d *	RETVAL;

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)) {
        v = (SFVec2d *)SvIV((SV*)SvRV( ST(1) ));
    }
    else {
        warn ( "SFVec2d::() -- v is not a blessed reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 251 "SFVec2d.xs"
switch(items-1) {
case 2:
	s = ST(2);
	RETVAL = const_cast<SFVec2d *>(THIS->subtract(v,s));
	break; /* case 2 */
default:
	RETVAL = const_cast<SFVec2d *>(THIS->subtract(v));
} /* switch(items) */ 
#line 499 "SFVec2d.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec2d", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_multiply); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_multiply)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::multiply(THIS, v, ...)");
    {
	double	v = (double)SvNV(ST(1));
#line 266 "SFVec2d.xs"
	SV *	s;
#line 518 "SFVec2d.c"
	SFVec2d *	THIS;
	SFVec2d *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 268 "SFVec2d.xs"
switch(items-1) {
case 2:
	s = ST(2);
	RETVAL = const_cast<SFVec2d *>(THIS->multiply(v,s));
	break; /* case 2 */
default:
	RETVAL = const_cast<SFVec2d *>(THIS->multiply(v));
} /* switch(items) */ 
#line 538 "SFVec2d.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec2d", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_divide); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_divide)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::divide(THIS, v, ...)");
    {
	double	v = (double)SvNV(ST(1));
#line 283 "SFVec2d.xs"
	SV *	s;
#line 557 "SFVec2d.c"
	SFVec2d *	THIS;
	SFVec2d *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 285 "SFVec2d.xs"
switch(items-1) {
case 2:
	s = ST(2);
	RETVAL = const_cast<SFVec2d *>(THIS->divide(v,s));
	break; /* case 2 */
default:
	RETVAL = const_cast<SFVec2d *>(THIS->divide(v));
} /* switch(items) */ 
#line 577 "SFVec2d.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec2d", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_dot); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_dot)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::dot(THIS, v, ...)");
    {
	SFVec2d *	v;
#line 300 "SFVec2d.xs"
	SV *	s;
#line 596 "SFVec2d.c"
	SFVec2d *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG)) {
        v = (SFVec2d *)SvIV((SV*)SvRV( ST(1) ));
    }
    else {
        warn ( "SFVec2d::() -- v is not a blessed reference" );
        XSRETURN_UNDEF;
    };

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 302 "SFVec2d.xs"
switch(items-1) {
case 2:
	s = ST(2);
	RETVAL = THIS->dot(v,s);
	break; /* case 2 */
default:
	RETVAL = THIS->dot(v);
} /* switch(items) */ 
#line 625 "SFVec2d.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_length); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_length)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::length(THIS, ...)");
    {
#line 316 "SFVec2d.xs"
	SV *	s;
#line 640 "SFVec2d.c"
	SFVec2d *	THIS;
	double	RETVAL;
	dXSTARG;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 318 "SFVec2d.xs"
switch(items-1) {
case 1:
	s = ST(1);
	RETVAL = THIS->length(s);
	break; /* case 1 */
default:
	RETVAL = THIS->length();
} /* switch(items) */ 
#line 661 "SFVec2d.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_normalize); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_normalize)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::normalize(THIS)");
    {
	SFVec2d *	THIS;
	SFVec2d *	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };
#line 332 "SFVec2d.xs"
	RETVAL = const_cast<SFVec2d *>(THIS->normalize());
#line 686 "SFVec2d.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), "SFVec2d", (void*)RETVAL );


    }
    XSRETURN(1);
}

XS(XS_main__SFVec2d_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_main__SFVec2d_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: main::SFVec2d::DESTROY(THIS)");
    {
	SFVec2d *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (SFVec2d *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "SFVec2d::() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    };

	delete THIS;
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_SFVec2d); /* prototype to pass -Wmissing-prototypes */
XS(boot_SFVec2d)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("main::SFVec2d::new", XS_main__SFVec2d_new, file);
        newXS("main::SFVec2d::copy", XS_main__SFVec2d_copy, file);
        newXS("main::SFVec2d::setValue", XS_main__SFVec2d_setValue, file);
        newXS("main::SFVec2d::getValue", XS_main__SFVec2d_getValue, file);
        newXS("main::SFVec2d::setX", XS_main__SFVec2d_setX, file);
        newXS("main::SFVec2d::setY", XS_main__SFVec2d_setY, file);
        newXS("main::SFVec2d::getX", XS_main__SFVec2d_getX, file);
        newXS("main::SFVec2d::getY", XS_main__SFVec2d_getY, file);
        newXS("main::SFVec2d::negate", XS_main__SFVec2d_negate, file);
        newXS("main::SFVec2d::add", XS_main__SFVec2d_add, file);
        newXS("main::SFVec2d::subtract", XS_main__SFVec2d_subtract, file);
        newXS("main::SFVec2d::multiply", XS_main__SFVec2d_multiply, file);
        newXS("main::SFVec2d::divide", XS_main__SFVec2d_divide, file);
        newXS("main::SFVec2d::dot", XS_main__SFVec2d_dot, file);
        newXS("main::SFVec2d::length", XS_main__SFVec2d_length, file);
        newXS("main::SFVec2d::normalize", XS_main__SFVec2d_normalize, file);
        newXS("main::SFVec2d::DESTROY", XS_main__SFVec2d_DESTROY, file);
    XSRETURN_YES;
}

